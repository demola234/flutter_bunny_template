import 'dart:io';

import 'package:mason/mason.dart';

import 'utils.dart';

void createStateManagementFiles(HookContext context, String projectName,
    String basePath, String featureName, String stateManagement) {
  switch (stateManagement) {
    case 'BLoC':
      createBlocFiles(context, projectName, '$basePath/bloc', featureName);
      break;
    case 'Provider':
      createProviderFiles(
          context, projectName, '$basePath/providers', featureName);
      break;
    case 'Riverpod':
      createRiverpodFiles(
          context, projectName, '$basePath/providers', featureName);
      break;
    case 'GetX':
      createGetXFiles(
          context, projectName, '$basePath/controllers', featureName);
      break;
    case 'MobX':
      createMobXFiles(context, projectName, '$basePath/stores', featureName);
      break;
    case 'Redux':
      createReduxFiles(context, projectName, '$basePath/redux', featureName);
      break;
    default:
      context.logger.warn('Unknown state management: $stateManagement');
  }
}

void createBlocFiles(HookContext context, String projectName, String blocPath,
    String featureName) {
  // Create the bloc directory if it doesn't exist
  final blocDir = Directory('$projectName/$blocPath');
  if (!blocDir.existsSync()) {
    blocDir.createSync(recursive: true);
    context.logger.info('Created BLoC directory: $blocPath');
  }

  // Create BLoC files
  createFile(
      '$projectName/$blocPath/${featureName}_bloc.dart',
      '''
// ${toClassName(featureName)}Bloc
// Generated by Flutter Bunny Cliüê∞
import 'package:flutter_bloc/flutter_bloc.dart';
import './${featureName}_event.dart';
import './${featureName}_state.dart';

class ${toClassName(featureName)}Bloc extends Bloc<${toClassName(featureName)}Event, ${toClassName(featureName)}State> {
  ${toClassName(featureName)}Bloc() : super(${toClassName(featureName)}Initial()) {
    on<${toClassName(featureName)}Started>(_on${toClassName(featureName)}Started);
    on<${toClassName(featureName)}Fetch>(_on${toClassName(featureName)}Fetch);
  }

  Future<void> _on${toClassName(featureName)}Started(
    ${toClassName(featureName)}Started event,
    Emitter<${toClassName(featureName)}State> emit,
  ) async {
    emit(${toClassName(featureName)}Initial());
  }

  Future<void> _on${toClassName(featureName)}Fetch(
    ${toClassName(featureName)}Fetch event,
    Emitter<${toClassName(featureName)}State> emit,
  ) async {
    emit(${toClassName(featureName)}Loading());
    try {
      // TODO: Implement fetching data
      // Example: final result = await repository.getData();
      emit(${toClassName(featureName)}Loaded([]));
    } catch (e) {
      emit(${toClassName(featureName)}Error(e.toString()));
    }
  }
}
''',
      context);

  createFile(
      '$projectName/$blocPath/${featureName}_event.dart',
      '''
// ${toClassName(featureName)}Event
// Generated by Flutter Bunny Cliüê∞

abstract class ${toClassName(featureName)}Event {
  const ${toClassName(featureName)}Event();
}

class ${toClassName(featureName)}Started extends ${toClassName(featureName)}Event {
  const ${toClassName(featureName)}Started();
}

class ${toClassName(featureName)}Fetch extends ${toClassName(featureName)}Event {
  const ${toClassName(featureName)}Fetch();
}

class ${toClassName(featureName)}Create extends ${toClassName(featureName)}Event {
  final dynamic data;
  const ${toClassName(featureName)}Create(this.data);
}

class ${toClassName(featureName)}Update extends ${toClassName(featureName)}Event {
  final String id;
  final dynamic data;
  const ${toClassName(featureName)}Update(this.id, this.data);
}

class ${toClassName(featureName)}Delete extends ${toClassName(featureName)}Event {
  final String id;
  const ${toClassName(featureName)}Delete(this.id);
}
''',
      context);

  createFile(
      '$projectName/$blocPath/${featureName}_state.dart',
      '''
// ${toClassName(featureName)}State
// Generated by Flutter Bunny Cliüê∞

abstract class ${toClassName(featureName)}State {
  const ${toClassName(featureName)}State();
}

class ${toClassName(featureName)}Initial extends ${toClassName(featureName)}State {}

class ${toClassName(featureName)}Loading extends ${toClassName(featureName)}State {}

class ${toClassName(featureName)}Loaded extends ${toClassName(featureName)}State {
  final List<dynamic> items;
  const ${toClassName(featureName)}Loaded(this.items);
}

class ${toClassName(featureName)}Error extends ${toClassName(featureName)}State {
  final String message;
  const ${toClassName(featureName)}Error(this.message);
}
''',
      context);
}

void createProviderFiles(HookContext context, String projectName,
    String providerPath, String featureName) {
  // Create the provider directory if it doesn't exist
  final providerDir = Directory('$projectName/$providerPath');
  if (!providerDir.existsSync()) {
    providerDir.createSync(recursive: true);
    context.logger.info('Created Provider directory: $providerPath');
  }

  // Create provider file
  createFile(
      '$projectName/$providerPath/${featureName}_provider.dart',
      '''
// ${toClassName(featureName)}Provider
// Generated by Flutter Bunny Cliüê∞
import 'package:flutter/foundation.dart';

class ${toClassName(featureName)}Provider extends ChangeNotifier {
  bool _isLoading = false;
  String? _errorMessage;
  List<dynamic> _items = [];
  
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  List<dynamic> get items => _items;
  
  Future<void> fetchData() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      // TODO: Implement API call or data fetch
      // Example: _items = await service.getItems();
      _items = [];
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  Future<void> createItem(dynamic item) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      // TODO: Implement create item
      // Example: await service.createItem(item);
      // _items.add(item);
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  Future<void> updateItem(String id, dynamic item) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      // TODO: Implement update item
      // Example: await service.updateItem(id, item);
      // Update item in _items list
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  Future<void> deleteItem(String id) async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      // TODO: Implement delete item
      // Example: await service.deleteItem(id);
      // Remove item from _items list
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}
''',
      context);
}

void createRiverpodFiles(HookContext context, String projectName,
    String riverpodPath, String featureName) {
  // Create the riverpod directory if it doesn't exist
  final riverpodDir = Directory('$projectName/$riverpodPath');
  if (!riverpodDir.existsSync()) {
    riverpodDir.createSync(recursive: true);
    context.logger.info('Created Riverpod directory: $riverpodPath');
  }

  // Create riverpod files
  createFile(
      '$projectName/$riverpodPath/${featureName}_provider.dart',
      '''
// ${toClassName(featureName)}Provider
// Generated by Flutter Bunny Cliüê∞
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State
class ${toClassName(featureName)}State {
  final bool isLoading;
  final String? errorMessage;
  final List<dynamic> items;
  
  const ${toClassName(featureName)}State({
    this.isLoading = false,
    this.errorMessage,
    this.items = const [],
  });
  
  ${toClassName(featureName)}State copyWith({
    bool? isLoading,
    String? errorMessage,
    List<dynamic>? items,
  }) {
    return ${toClassName(featureName)}State(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
      items: items ?? this.items,
    );
  }
}

// Provider
final ${featureName}Provider = StateNotifierProvider<${toClassName(featureName)}Notifier, ${toClassName(featureName)}State>((ref) {
  return ${toClassName(featureName)}Notifier();
});

// Notifier
class ${toClassName(featureName)}Notifier extends StateNotifier<${toClassName(featureName)}State> {
  ${toClassName(featureName)}Notifier() : super(const ${toClassName(featureName)}State()) {
    fetchData();
  }
  
  Future<void> fetchData() async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      // TODO: Implement API call or data fetch
      // Example: final items = await service.getItems();
      final items = [];
      state = state.copyWith(isLoading: false, items: items);
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
    }
  }
  
  Future<void> createItem(dynamic item) async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      // TODO: Implement create item
      // Example: await service.createItem(item);
      // Update state with new item
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
    }
  }
  
  Future<void> updateItem(String id, dynamic item) async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      // TODO: Implement update item
      // Example: await service.updateItem(id, item);
      // Update state with updated item
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
    }
  }
  
  Future<void> deleteItem(String id) async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      // TODO: Implement delete item
      // Example: await service.deleteItem(id);
      // Update state by removing item
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
    }
  }
}
''',
      context);
}

void createGetXFiles(HookContext context, String projectName, String getxPath,
    String featureName) {
  // Create the GetX directory if it doesn't exist
  final getxDir = Directory('$projectName/$getxPath');
  if (!getxDir.existsSync()) {
    getxDir.createSync(recursive: true);
    context.logger.info('Created GetX directory: $getxPath');
  }

  // Create GetX controller file
  createFile(
      '$projectName/$getxPath/${featureName}_controller.dart',
      '''
// ${toClassName(featureName)}Controller
// Generated by Flutter Bunny Cliüê∞
import 'package:get/get.dart';

class ${toClassName(featureName)}Controller extends GetxController {
  final RxBool isLoading = false.obs;
  final Rx<String?> errorMessage = Rx<String?>(null);
  final RxList<dynamic> items = <dynamic>[].obs;
  
  @override
  void onInit() {
    super.onInit();
    fetchData();
  }
  
  Future<void> fetchData() async {
    isLoading.value = true;
    errorMessage.value = null;
    
    try {
      // TODO: Implement API call or data fetch
      // Example: final result = await service.getItems();
      items.clear();
      // items.addAll(result);
    } catch (e) {
      errorMessage.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }
  
  Future<void> createItem(dynamic item) async {
    isLoading.value = true;
    errorMessage.value = null;
    
    try {
      // TODO: Implement create item
      // Example: await service.createItem(item);
      // items.add(item);
    } catch (e) {
      errorMessage.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }
  
  Future<void> updateItem(String id, dynamic item) async {
    isLoading.value = true;
    errorMessage.value = null;
    
    try {
      // TODO: Implement update item
      // Example: await service.updateItem(id, item);
      // Update item in items list
    } catch (e) {
      errorMessage.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }
  
  Future<void> deleteItem(String id) async {
    isLoading.value = true;
    errorMessage.value = null;
    
    try {
      // TODO: Implement delete item
      // Example: await service.deleteItem(id);
      // Remove item from items list
    } catch (e) {
      errorMessage.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }
}
''',
      context);
}

void createMobXFiles(HookContext context, String projectName, String mobxPath,
    String featureName) {
  // Create the MobX directory if it doesn't exist
  final mobxDir = Directory('$projectName/$mobxPath');
  if (!mobxDir.existsSync()) {
    mobxDir.createSync(recursive: true);
    context.logger.info('Created MobX directory: $mobxPath');
  }

  // Create MobX store file
  createFile(
      '$projectName/$mobxPath/${featureName}_store.dart',
      '''
// ${toClassName(featureName)}Store
// Generated by Flutter Bunny Cliüê∞
import 'package:mobx/mobx.dart';

// Include generated file
part '${featureName}_store.g.dart';

// This is the class used by rest of the codebase
class ${toClassName(featureName)}Store = _${toClassName(featureName)}Store with _\$${toClassName(featureName)}Store;

// The store class
abstract class _${toClassName(featureName)}Store with Store {
  @observable
  bool isLoading = false;

  @observable
  String? errorMessage;
  
  @observable
  ObservableList<dynamic> items = ObservableList<dynamic>();
  
  @action
  Future<void> fetchData() async {
    isLoading = true;
    errorMessage = null;
    
    try {
      // TODO: Implement API call or data fetch
      // Example: final result = await service.getItems();
      items.clear();
      // items.addAll(result);
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
  
  @action
  Future<void> createItem(dynamic item) async {
    isLoading = true;
    errorMessage = null;
    
    try {
      // TODO: Implement create item
      // Example: await service.createItem(item);
      // items.add(item);
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
  
  @action
  Future<void> updateItem(String id, dynamic item) async {
    isLoading = true;
    errorMessage = null;
    
    try {
      // TODO: Implement update item
      // Example: await service.updateItem(id, item);
      // Update item in items list
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
  
  @action
  Future<void> deleteItem(String id) async {
    isLoading = true;
    errorMessage = null;
    
    try {
      // TODO: Implement delete item
      // Example: await service.deleteItem(id);
      // Remove item from items list
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
}
''',
      context);
}

void createReduxFiles(HookContext context, String projectName, String reduxPath,
    String featureName) {
  // Create the Redux directory and subdirectories if they don't exist
  final reduxDirs = [
    '$reduxPath',
    '$reduxPath/actions',
    '$reduxPath/reducers',
    '$reduxPath/middleware',
    '$reduxPath/state',
  ];

  for (final dir in reduxDirs) {
    final directory = Directory('$projectName/$dir');
    if (!directory.existsSync()) {
      directory.createSync(recursive: true);
      context.logger.info('Created Redux directory: $dir');
    }
  }

  // Create Redux action file
  createFile(
      '$projectName/$reduxPath/actions/${featureName}_actions.dart',
      '''
// ${toClassName(featureName)}Actions
// Generated by Flutter Bunny Cliüê∞

class ${toClassName(featureName)}FetchAction {
  const ${toClassName(featureName)}FetchAction();
}

class ${toClassName(featureName)}FetchSuccessAction {
  final List<dynamic> items;
  const ${toClassName(featureName)}FetchSuccessAction(this.items);
}

class ${toClassName(featureName)}FetchFailureAction {
  final String error;
  const ${toClassName(featureName)}FetchFailureAction(this.error);
}

class ${toClassName(featureName)}CreateAction {
  final dynamic item;
  const ${toClassName(featureName)}CreateAction(this.item);
}

class ${toClassName(featureName)}UpdateAction {
  final String id;
  final dynamic item;
  const ${toClassName(featureName)}UpdateAction(this.id, this.item);
}

class ${toClassName(featureName)}DeleteAction {
  final String id;
  const ${toClassName(featureName)}DeleteAction(this.id);
}
''',
      context);

  // Create Redux state file
  createFile(
      '$projectName/$reduxPath/state/${featureName}_state.dart',
      '''
// ${toClassName(featureName)}State
// Generated by Flutter Bunny Cliüê∞

class ${toClassName(featureName)}State {
  final bool isLoading;
  final String? errorMessage;
  final List<dynamic> items;
  
  const ${toClassName(featureName)}State({
    this.isLoading = false,
    this.errorMessage,
    this.items = const [],
  });
  
  ${toClassName(featureName)}State copyWith({
    bool? isLoading,
    String? errorMessage,
    List<dynamic>? items,
  }) {
    return ${toClassName(featureName)}State(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
      items: items ?? this.items,
    );
  }
  
  factory ${toClassName(featureName)}State.initial() {
    return const ${toClassName(featureName)}State();
  }
}
''',
      context);

  // Create Redux reducer file
  createFile(
      '$projectName/$reduxPath/reducers/${featureName}_reducer.dart',
      '''
// ${toClassName(featureName)}Reducer
// Generated by Flutter Bunny Cliüê∞
import '../actions/${featureName}_actions.dart';
import '../state/${featureName}_state.dart';

${toClassName(featureName)}State ${featureName}Reducer(${toClassName(featureName)}State state, dynamic action) {
  if (action is ${toClassName(featureName)}FetchAction) {
    return state.copyWith(
      isLoading: true,
      errorMessage: null,
    );
  } else if (action is ${toClassName(featureName)}FetchSuccessAction) {
    return state.copyWith(
      isLoading: false,
      items: action.items,
    );
  } else if (action is ${toClassName(featureName)}FetchFailureAction) {
    return state.copyWith(
      isLoading: false,
      errorMessage: action.error,
    );
  }
  
  return state;
}
''',
      context);

  // Create Redux middleware file
  createFile(
      '$projectName/$reduxPath/middleware/${featureName}_middleware.dart',
      '''
// ${toClassName(featureName)}Middleware
// Generated by Flutter Bunny Cliüê∞
import 'package:redux/redux.dart';
import '../actions/${featureName}_actions.dart';
import '../state/${featureName}_state.dart';

List<Middleware<${toClassName(featureName)}State>> create${toClassName(featureName)}Middleware() {
  return [
    TypedMiddleware<${toClassName(featureName)}State, ${toClassName(featureName)}FetchAction>(_onFetch),
    TypedMiddleware<${toClassName(featureName)}State, ${toClassName(featureName)}CreateAction>(_onCreate),
    TypedMiddleware<${toClassName(featureName)}State, ${toClassName(featureName)}UpdateAction>(_onUpdate),
    TypedMiddleware<${toClassName(featureName)}State, ${toClassName(featureName)}DeleteAction>(_onDelete),
  ];
}

void _onFetch(Store<${toClassName(featureName)}State> store, ${toClassName(featureName)}FetchAction action, NextDispatcher next) async {
  next(action);
  
  try {
    // TODO: Implement API call or data fetch
    // Example: final items = await service.getItems();
    final items = [];
    store.dispatch(${toClassName(featureName)}FetchSuccessAction(items));
  } catch (e) {
    store.dispatch(${toClassName(featureName)}FetchFailureAction(e.toString()));
  }
}

void _onCreate(Store<${toClassName(featureName)}State> store, ${toClassName(featureName)}CreateAction action, NextDispatcher next) async {
  next(action);
  
  try {
    // TODO: Implement create item
    // Example: await service.createItem(action.item);
    store.dispatch(${toClassName(featureName)}FetchAction());
  } catch (e) {
    store.dispatch(${toClassName(featureName)}FetchFailureAction(e.toString()));
  }
}

void _onUpdate(Store<${toClassName(featureName)}State> store, ${toClassName(featureName)}UpdateAction action, NextDispatcher next) async {
  next(action);
  
  try {
    // TODO: Implement update item
    // Example: await service.updateItem(action.id, action.item);
    store.dispatch(${toClassName(featureName)}FetchAction());
  } catch (e) {
    store.dispatch(${toClassName(featureName)}FetchFailureAction(e.toString()));
  }
}

void _onDelete(Store<${toClassName(featureName)}State> store, ${toClassName(featureName)}DeleteAction action, NextDispatcher next) async {
  next(action);
  
  try {
    // TODO: Implement delete item
    // Example: await service.deleteItem(action.id);
    store.dispatch(${toClassName(featureName)}FetchAction());
  } catch (e) {
    store.dispatch(${toClassName(featureName)}FetchFailureAction(e.toString()));
  }
}
''',
      context);
}

// Template generator helper functions
String generateProviderViewModel(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}ViewModel with Provider
// Generated by Flutter Bunny Cliüê∞
import 'package:flutter/foundation.dart';


class ${className}ViewModel extends ChangeNotifier {
  
  
  bool _isLoading = false;
  String? _errorMessage;
  List<dynamic> _items = [];
  
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  List<dynamic> get items => _items;
  
  Future<void> fetchData() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      // TODO: Implement data fetching
      // Example: _items = await _service.getItems();
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}
''';
}

String generateRiverpodViewModel(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}ViewModel with Riverpod
// Generated by Flutter Bunny Cliüê∞
import 'package:flutter_riverpod/flutter_riverpod.dart';


// State class
class ${className}State {
  final bool isLoading;
  final String? errorMessage;
  final List<dynamic> items;
  
  const ${className}State({
    this.isLoading = false,
    this.errorMessage,
    this.items = const [],
  });
  
  ${className}State copyWith({
    bool? isLoading,
    String? errorMessage,
    List<dynamic>? items,
  }) {
    return ${className}State(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
      items: items ?? this.items,
    );
  }
}

// Provider
final ${featureName}Provider = StateNotifierProvider<${className}ViewModel, ${className}State>((ref) {
  return ${className}ViewModel();
});

// ViewModel
class ${className}ViewModel extends StateNotifier<${className}State> {
  
  
  ${className}ViewModel() : super(const ${className}State()) {
    fetchData();
  }
  
  Future<void> fetchData() async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      // TODO: Implement data fetching
      // Example: final items = await _service.getItems();
      // state = state.copyWith(items: items, isLoading: false);
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: e.toString(),
      );
    }
  }
}
''';
}

String generateGetXViewModel(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}ViewModel with GetX
// Generated by Flutter Bunny Cliüê∞
import 'package:get/get.dart';


class ${className}ViewModel extends GetxController {
  
  
  final RxBool isLoading = false.obs;
  final Rx<String?> errorMessage = Rx<String?>(null);
  final RxList<dynamic> items = <dynamic>[].obs;
  
  @override
  void onInit() {
    super.onInit();
    fetchData();
  }
  
  Future<void> fetchData() async {
    isLoading.value = true;
    errorMessage.value = null;
    
    try {
      // TODO: Implement data fetching
      // Example: final result = await _service.getItems();
      // items.value = result;
    } catch (e) {
      errorMessage.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }
}
''';
}

String generateMobXViewModel(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}ViewModel with MobX
// Generated by Flutter Bunny Cliüê∞
import 'package:mobx/mobx.dart';


// Include generated file
part '${featureName}_viewmodel.g.dart';

// This is the class used by rest of the codebase
class ${className}ViewModel = _${className}ViewModel with _\$${className}ViewModel;

// The store class
abstract class _${className}ViewModel with Store {
  
  
  @observable
  bool isLoading = false;

  @observable
  String? errorMessage;
  
  @observable
  ObservableList<dynamic> items = ObservableList<dynamic>();
  
  _${className}ViewModel() {
    fetchData();
  }
  
  @action
  Future<void> fetchData() async {
    isLoading = true;
    errorMessage = null;
    
    try {
      // TODO: Implement data fetching
      // Example: final result = await _service.getItems();
      // items.clear();
      // items.addAll(result);
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
}
''';
}

// Continuing from previous file...

String generateBasicViewModel(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}ViewModel basic implementation
// Generated by Flutter Bunny Cliüê∞


class ${className}ViewModel {
  
  
  bool isLoading = false;
  String? errorMessage;
  List<dynamic> items = [];
  
  Future<void> fetchData() async {
    isLoading = true;
    
    try {
      // TODO: Implement data fetching
      // Example: items = await _service.getItems();
      errorMessage = null;
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
}
''';
}

// Helper methods for generating feature-specific files for different architectures

// Authentication feature specific files

// Generate authentication entity for Clean Architecture
String generateAuthenticationEntity() {
  return '''
// User Entity
// Generated by Flutter Bunny Cliüê∞

enum AuthStatus {
  unknown,
  authenticated,
  unauthenticated,
  unverified,
}

class User {
  final String id;
  final String email;
  final String? displayName;
  final String? photoUrl;
  final AuthStatus status;
  
  User({
    required this.id,
    required this.email,
    this.displayName,
    this.photoUrl,
    this.status = AuthStatus.unknown,
  });
  
  User copyWith({
    String? id,
    String? email,
    String? displayName,
    String? photoUrl,
    AuthStatus? status,
  }) {
    return User(
      id: id ?? this.id,
      email: email ?? this.email,
      displayName: displayName ?? this.displayName,
      photoUrl: photoUrl ?? this.photoUrl,
      status: status ?? this.status,
    );
  }
}
''';
}

// Generate authentication repository for Clean Architecture
String generateAuthenticationRepository() {
  return '''
// Authentication Repository Interface
// Generated by Flutter Bunny Cliüê∞
import '../entities/user.dart';

abstract class AuthRepository {
  Future<User> signInWithEmailAndPassword(String email, String password);
  Future<User> signUpWithEmailAndPassword(String email, String password);
  Future<void> signOut();
  Future<User?> getCurrentUser();
  Future<bool> isSignedIn();
  Future<void> sendPasswordResetEmail(String email);
}
''';
}

// Generate authentication use cases for Clean Architecture
String generateAuthenticationUseCases() {
  return '''
// Authentication Use Cases
// Generated by Flutter Bunny Cliüê∞
import '../entities/user.dart';
import '../repositories/auth_repository.dart';

class SignInUseCase {
  final AuthRepository repository;
  
  SignInUseCase(this.repository);
  
  Future<User> execute(String email, String password) {
    return repository.signInWithEmailAndPassword(email, password);
  }
}

class SignUpUseCase {
  final AuthRepository repository;
  
  SignUpUseCase(this.repository);
  
  Future<User> execute(String email, String password) {
    return repository.signUpWithEmailAndPassword(email, password);
  }
}

class SignOutUseCase {
  final AuthRepository repository;
  
  SignOutUseCase(this.repository);
  
  Future<void> execute() {
    return repository.signOut();
  }
}

class GetCurrentUserUseCase {
  final AuthRepository repository;
  
  GetCurrentUserUseCase(this.repository);
  
  Future<User?> execute() {
    return repository.getCurrentUser();
  }
}

class IsSignedInUseCase {
  final AuthRepository repository;
  
  IsSignedInUseCase(this.repository);
  
  Future<bool> execute() {
    return repository.isSignedIn();
  }
}

class SendPasswordResetEmailUseCase {
  final AuthRepository repository;
  
  SendPasswordResetEmailUseCase(this.repository);
  
  Future<void> execute(String email) {
    return repository.sendPasswordResetEmail(email);
  }
}
''';
}

// Generate authentication model for Clean Architecture
String generateAuthenticationModel() {
  return '''
// User Model
// Generated by Flutter Bunny Cliüê∞
import '../../domain/entities/user.dart';

class UserModel extends User {
  UserModel({
    required String id,
    required String email,
    String? displayName,
    String? photoUrl,
    AuthStatus status = AuthStatus.unknown,
  }) : super(
    id: id,
    email: email,
    displayName: displayName,
    photoUrl: photoUrl,
    status: status,
  );
  
  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id'],
      email: json['email'],
      displayName: json['displayName'],
      photoUrl: json['photoUrl'],
      status: AuthStatus.values[json['status'] ?? 0],
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'displayName': displayName,
      'photoUrl': photoUrl,
      'status': status.index,
    };
  }
  
  factory UserModel.fromEntity(User user) {
    return UserModel(
      id: user.id,
      email: user.email,
      displayName: user.displayName,
      photoUrl: user.photoUrl,
      status: user.status,
    );
  }
}
''';
}

// Generate authentication data source for Clean Architecture
String generateAuthenticationDataSource() {
  return '''
// Authentication Data Sources
// Generated by Flutter Bunny Cliüê∞
import '../models/user_model.dart';

abstract class AuthRemoteDataSource {
  Future<UserModel> signInWithEmailAndPassword(String email, String password);
  Future<UserModel> signUpWithEmailAndPassword(String email, String password);
  Future<void> signOut();
  Future<UserModel?> getCurrentUser();
  Future<bool> isSignedIn();
  Future<void> sendPasswordResetEmail(String email);
}

class AuthRemoteDataSourceImpl implements AuthRemoteDataSource {
  // TODO: Implement with Firebase Auth or any other auth provider
  
  @override
  Future<UserModel> signInWithEmailAndPassword(String email, String password) async {
    // TODO: Implement actual sign in
    // This is just a placeholder
    return UserModel(
      id: 'user_id',
      email: email,
      status: AuthStatus.authenticated,
    );
  }
  
  @override
  Future<UserModel> signUpWithEmailAndPassword(String email, String password) async {
    // TODO: Implement actual sign up
    // This is just a placeholder
    return UserModel(
      id: 'new_user_id',
      email: email,
      status: AuthStatus.authenticated,
    );
  }
  
  @override
  Future<void> signOut() async {
    // TODO: Implement actual sign out
  }
  
  @override
  Future<UserModel?> getCurrentUser() async {
    // TODO: Implement actual get current user
    return null; 
  }
  
  @override
  Future<bool> isSignedIn() async {
    // TODO: Implement actual check
    return false;
  }
  
  @override
  Future<void> sendPasswordResetEmail(String email) async {
    // TODO: Implement actual password reset
  }
}

abstract class AuthLocalDataSource {
  Future<void> cacheUser(UserModel user);
  Future<void> clearUser();
  Future<UserModel?> getLastUser();
}

class AuthLocalDataSourceImpl implements AuthLocalDataSource {
  // TODO: Implement with shared preferences, secure storage, or any local storage
  
  @override
  Future<void> cacheUser(UserModel user) async {
    // TODO: Implement caching user
  }
  
  @override
  Future<void> clearUser() async {
    // TODO: Implement clearing cached user
  }
  
  @override
  Future<UserModel?> getLastUser() async {
    // TODO: Implement getting cached user
    return null;
  }
}
''';
}

// Generate authentication repository implementation for Clean Architecture
String generateAuthenticationRepositoryImpl() {
  return '''
// Authentication Repository Implementation
// Generated by Flutter Bunny Cliüê∞
import '../../domain/entities/user.dart';
import '../../domain/repositories/auth_repository.dart';
import '../datasources/auth_data_source.dart';
import '../models/user_model.dart';

class AuthRepositoryImpl implements AuthRepository {
  final AuthRemoteDataSource remoteDataSource;
  final AuthLocalDataSource localDataSource;
  
  AuthRepositoryImpl({
    required this.remoteDataSource,
    required this.localDataSource,
  });
  
  @override
  Future<User> signInWithEmailAndPassword(String email, String password) async {
    final userModel = await remoteDataSource.signInWithEmailAndPassword(email, password);
    await localDataSource.cacheUser(userModel);
    return userModel;
  }
  
  @override
  Future<User> signUpWithEmailAndPassword(String email, String password) async {
    final userModel = await remoteDataSource.signUpWithEmailAndPassword(email, password);
    await localDataSource.cacheUser(userModel);
    return userModel;
  }
  
  @override
  Future<void> signOut() async {
    await remoteDataSource.signOut();
    await localDataSource.clearUser();
  }
  
  @override
  Future<User?> getCurrentUser() async {
    try {
      // First try to get from remote
      return await remoteDataSource.getCurrentUser();
    } catch (_) {
      // If remote fails, try from local cache
      return await localDataSource.getLastUser();
    }
  }
  
  @override
  Future<bool> isSignedIn() async {
    return await remoteDataSource.isSignedIn();
  }
  
  @override
  Future<void> sendPasswordResetEmail(String email) async {
    await remoteDataSource.sendPasswordResetEmail(email);
  }
}
''';
}

// Generate authentication screens for Clean Architecture
String generateAuthenticationScreens() {
  return '''
// Login Screen
// Generated by Flutter Bunny Cliüê∞
import 'package:flutter/material.dart';

class LoginScreen extends StatefulWidget {
  const LoginScreen({Key? key}) : super(key: key);

  @override
  _LoginScreenState createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  void _togglePasswordVisibility() {
    setState(() {
      _obscurePassword = !_obscurePassword;
    });
  }

  Future<void> _login() async {
    if (_formKey.currentState?.validate() ?? false) {
      setState(() {
        _isLoading = true;
      });

      try {
        // TODO: Implement login logic with state management
        // Example: await authBloc.add(LoginEvent(_emailController.text, _passwordController.text));
        
        // Navigate to home on success
        // Navigator.of(context).pushReplacementNamed('/home');
      } catch (e) {
        // Show error
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(e.toString())),
        );
      } finally {
        if (mounted) {
          setState(() {
            _isLoading = false;
          });
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Login'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              TextFormField(
                controller: _emailController,
                keyboardType: TextInputType.emailAddress,
                decoration: const InputDecoration(
                  labelText: 'Email',
                  border: OutlineInputBorder(),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter your email';
                  }
                  if (!value.contains('@')) {
                    return 'Please enter a valid email';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _passwordController,
                obscureText: _obscurePassword,
                decoration: InputDecoration(
                  labelText: 'Password',
                  border: const OutlineInputBorder(),
                  suffixIcon: IconButton(
                    icon: Icon(
                      _obscurePassword ? Icons.visibility : Icons.visibility_off,
                    ),
                    onPressed: _togglePasswordVisibility,
                  ),
                ),
                validator: (value) {
                  if (value == null || value.isEmpty) {
                    return 'Please enter your password';
                  }
                  if (value.length < 6) {
                    return 'Password must be at least 6 characters';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: _isLoading ? null : _login,
                child: _isLoading
                    ? const CircularProgressIndicator()
                    : const Text('Login'),
              ),
              const SizedBox(height: 16),
              TextButton(
                onPressed: () {
                  // Navigate to forgot password
                  // Navigator.of(context).pushNamed('/forgot-password');
                },
                child: const Text('Forgot Password?'),
              ),
              TextButton(
                onPressed: () {
                  // Navigate to register
                  // Navigator.of(context).pushNamed('/register');
                },
                child: const Text('Don\\'t have an account? Register'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
''';
}
