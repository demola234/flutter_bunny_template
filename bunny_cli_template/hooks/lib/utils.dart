import 'dart:io';
import 'package:mason/mason.dart';

bool isValidProjectName(String name) {
  final projectNameRegex = RegExp(r'^[a-z_][a-z0-9_]*$');
  return projectNameRegex.hasMatch(name);
}

void createFile(String path, String content, HookContext context) {
  final file = File(path);
  if (!file.existsSync()) {
    file.writeAsStringSync(content);
    context.logger.info('Created file: $path');
  }
}

String toClassName(String name) {
  final parts = name.split('_');
  return parts.map((part) => part.isNotEmpty ? part[0].toUpperCase() + part.substring(1) : '').join('');
}

// Template generator for entities
String generateEntityTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Entity
// This file was auto-generated by Mason

class ${className}Entity {
  final String id;
  final String name;
  // Add more fields as needed
  
  ${className}Entity({
    required this.id,
    required this.name,
  });
}
''';
}

// Template for repository interface
String generateRepositoryTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Repository interface
// This file was auto-generated by Mason
import '../entities/${featureName}_entity.dart';

abstract class ${className}Repository {
  Future<List<${className}Entity>> getAll();
  Future<${className}Entity> getById(String id);
  Future<void> create(${className}Entity entity);
  Future<void> update(${className}Entity entity);
  Future<void> delete(String id);
}
''';
}

// Template for use case
String generateUseCaseTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}UseCase
// This file was auto-generated by Mason
import '../entities/${featureName}_entity.dart';
import '../repositories/${featureName}_repository.dart';

class Get${className}UseCase {
  final ${className}Repository repository;
  
  Get${className}UseCase(this.repository);
  
  Future<List<${className}Entity>> execute() {
    return repository.getAll();
  }
}

class Get${className}ByIdUseCase {
  final ${className}Repository repository;
  
  Get${className}ByIdUseCase(this.repository);
  
  Future<${className}Entity> execute(String id) {
    return repository.getById(id);
  }
}
''';
}

// Template for model
String generateModelTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Model
// This file was auto-generated by Mason
import '../../domain/entities/${featureName}_entity.dart';

class ${className}Model extends ${className}Entity {
  ${className}Model({
    required String id,
    required String name,
  }) : super(
    id: id,
    name: name,
  );
  
  factory ${className}Model.fromJson(Map<String, dynamic> json) {
    return ${className}Model(
      id: json['id'],
      name: json['name'],
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
    };
  }
  
  factory ${className}Model.fromEntity(${className}Entity entity) {
    return ${className}Model(
      id: entity.id,
      name: entity.name,
    );
  }
}
''';
}

// Template for repository implementation
String generateRepositoryImplTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}RepositoryImpl
// This file was auto-generated by Mason
import '../../domain/entities/${featureName}_entity.dart';
import '../../domain/repositories/${featureName}_repository.dart';
import '../datasources/${featureName}_data_source.dart';
import '../models/${featureName}_model.dart';

class ${className}RepositoryImpl implements ${className}Repository {
  final ${className}DataSource dataSource;
  
  ${className}RepositoryImpl({
    required this.dataSource,
  });
  
  @override
  Future<List<${className}Entity>> getAll() async {
    final result = await dataSource.getAll();
    return result.map((model) => model).toList();
  }
  
  @override
  Future<${className}Entity> getById(String id) async {
    return await dataSource.getById(id);
  }
  
  @override
  Future<void> create(${className}Entity entity) async {
    await dataSource.create(${className}Model.fromEntity(entity));
  }
  
  @override
  Future<void> update(${className}Entity entity) async {
    await dataSource.update(${className}Model.fromEntity(entity));
  }
  
  @override
  Future<void> delete(String id) async {
    await dataSource.delete(id);
  }
}
''';
}

// Template for data source
String generateDataSourceTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}DataSource
// This file was auto-generated by Mason
import '../models/${featureName}_model.dart';

abstract class ${className}DataSource {
  Future<List<${className}Model>> getAll();
  Future<${className}Model> getById(String id);
  Future<void> create(${className}Model model);
  Future<void> update(${className}Model model);
  Future<void> delete(String id);
}

class ${className}RemoteDataSource implements ${className}DataSource {
  // TODO: Implement remote data source (API calls, etc.)
  
  @override
  Future<List<${className}Model>> getAll() async {
    // TODO: Implement API call
    return [];
  }
  
  @override
  Future<${className}Model> getById(String id) async {
    // TODO: Implement API call
    throw UnimplementedError();
  }
  
  @override
  Future<void> create(${className}Model model) async {
    // TODO: Implement API call
  }
  
  @override
  Future<void> update(${className}Model model) async {
    // TODO: Implement API call
  }
  
  @override
  Future<void> delete(String id) async {
    // TODO: Implement API call
  }
}

class ${className}LocalDataSource implements ${className}DataSource {
  // TODO: Implement local data source (shared prefs, database, etc.)
  
  @override
  Future<List<${className}Model>> getAll() async {
    // TODO: Implement local storage retrieval
    return [];
  }
  
  @override
  Future<${className}Model> getById(String id) async {
    // TODO: Implement local storage retrieval
    throw UnimplementedError();
  }
  
  @override
  Future<void> create(${className}Model model) async {
    // TODO: Implement local storage saving
  }
  
  @override
  Future<void> update(${className}Model model) async {
    // TODO: Implement local storage updating
  }
  
  @override
  Future<void> delete(String id) async {
    // TODO: Implement local storage deletion
  }
}
''';
}

// Template for page
String generatePageTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Page
// This file was auto-generated by Mason
import 'package:flutter/material.dart';
import '../widgets/${featureName}_widget.dart';

class ${className}Page extends StatelessWidget {
  const ${className}Page({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('${className}'),
      ),
      body: ${className}Widget(),
    );
  }
}
''';
}

// Template for widget
String generateWidgetTemplate(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Widget
// This file was auto-generated by Mason
import 'package:flutter/material.dart';

class ${className}Widget extends StatelessWidget {
  const ${className}Widget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text('${className} Feature'),
    );
  }
}
''';
}

// Template for service
String generateServiceTemplate(String moduleName) {
  final className = toClassName(moduleName);
  return '''
// ${className}Service
// This file was auto-generated by Mason

class ${className}Service {
  // TODO: Add service methods and properties
  
  Future<void> initialize() async {
    // TODO: Implement initialization logic
  }
}
''';
}

// Template for controller
String generateBasicController(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Controller basic implementation
// Generated by Mason

class ${className}Controller {
  bool isLoading = false;
  String? errorMessage;
  List<dynamic> items = [];
  
  Future<void> fetchData() async {
    isLoading = true;
    
    try {
      // TODO: Implement data fetching
      errorMessage = null;
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
}
''';
}

String generateProviderController(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Controller with Provider
// Generated by Mason
import 'package:flutter/foundation.dart';
import '../services/${featureName}_service.dart';

class ${className}Controller extends ChangeNotifier {
  final ${className}Service _service = ${className}Service();
  
  bool _isLoading = false;
  String? _errorMessage;
  List<dynamic> _items = [];
  
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;
  List<dynamic> get items => _items;
  
  Future<void> fetchData() async {
    _isLoading = true;
    _errorMessage = null;
    notifyListeners();
    
    try {
      // TODO: Implement data fetching
      // Example: _items = await _service.getItems();
    } catch (e) {
      _errorMessage = e.toString();
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}
''';
}

String generateRiverpodController(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Controller with Riverpod
// Generated by Mason
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/${featureName}_service.dart';

// State class
class ${className}State {
  final bool isLoading;
  final String? errorMessage;
  final List<dynamic> items;
  
  const ${className}State({
    this.isLoading = false,
    this.errorMessage,
    this.items = const [],
  });
  
  ${className}State copyWith({
    bool? isLoading,
    String? errorMessage,
    List<dynamic>? items,
  }) {
    return ${className}State(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage ?? this.errorMessage,
      items: items ?? this.items,
    );
  }
}

// Provider
final ${featureName}Provider = StateNotifierProvider<${className}Controller, ${className}State>((ref) {
  return ${className}Controller();
});

// Controller
class ${className}Controller extends StateNotifier<${className}State> {
  final ${className}Service _service = ${className}Service();
  
  ${className}Controller() : super(const ${className}State()) {
    fetchData();
  }
  
  Future<void> fetchData() async {
    state = state.copyWith(isLoading: true, errorMessage: null);
    
    try {
      // TODO: Implement data fetching
      // Example: final items = await _service.getItems();
      // state = state.copyWith(items: items, isLoading: false);
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        errorMessage: e.toString(),
      );
    }
  }
}
''';
}

String generateGetXController(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Controller with GetX
// Generated by Mason
import 'package:get/get.dart';
import '../services/${featureName}_service.dart';

class ${className}Controller extends GetxController {
  final ${className}Service _service = ${className}Service();
  
  final RxBool isLoading = false.obs;
  final Rx<String?> errorMessage = Rx<String?>(null);
  final RxList<dynamic> items = <dynamic>[].obs;
  
  @override
  void onInit() {
    super.onInit();
    fetchData();
  }
  
  Future<void> fetchData() async {
    isLoading.value = true;
    errorMessage.value = null;
    
    try {
      // TODO: Implement data fetching
      // Example: final result = await _service.getItems();
      // items.value = result;
    } catch (e) {
      errorMessage.value = e.toString();
    } finally {
      isLoading.value = false;
    }
  }
}
''';
}

String generateMobXController(String featureName) {
  final className = toClassName(featureName);
  return '''
// ${className}Controller with MobX
// Generated by Mason
import 'package:mobx/mobx.dart';
import '../services/${featureName}_service.dart';

// Include generated file
part '${featureName}_controller.g.dart';

// This is the class used by rest of the codebase
class ${className}Controller = _${className}Controller with _\$${className}Controller;

// The controller class
abstract class _${className}Controller with Store {
  final ${className}Service _service = ${className}Service();
  
  @observable
  bool isLoading = false;

  @observable
  String? errorMessage;
  
  @observable
  ObservableList<dynamic> items = ObservableList<dynamic>();
  
  _${className}Controller() {
    fetchData();
  }
  
  @action
  Future<void> fetchData() async {
    isLoading = true;
    errorMessage = null;
    
    try {
      // TODO: Implement data fetching
      // Example: final result = await _service.getItems();
      // items.clear();
      // items.addAll(result);
    } catch (e) {
      errorMessage = e.toString();
    } finally {
      isLoading = false;
    }
  }
}
''';
}